# SCRR-FX: Известная проблема — точность при cancellation (k=8)

## TL;DR

Даже при `k=8` (и выше) SCRR иногда показывает **хуже точность, чем float64** на паттернах типа `1.0 - (1.0 - eps)` (catastrophic cancellation). Это не должно происходить — SCRR с таким k должен гарантировать точность существенно выше float64, особенно на простых выражениях.

## Симптомы
- Тесты типа:
  - `1.0 - (1.0 - 1e-16)`
  - `SCRR_Tensor.from_float(1.0, k=8) - SCRR_Tensor.from_float(1.0 - 1e-16, k=8)`
- Ожидается, что SCRR даст результат ближе к ground truth (mpmath, float128), но head компонента и остатки после ренормализации дают 0, итоговая ошибка — 1.0 (хуже float64).
- Аналогично для других cancellation-паттернов и некоторых property-based тестов.

## Почему это важно
- k=8 — это не "малое k". SCRR с таким количеством компонент должен эмулировать float128/256 и быть устойчивым к cancellation.
- Если SCRR хуже float64 на cancellation, это либо баг в ренормализации, либо в логике накопления ошибок, либо в реализации TwoSum/TwoProd.
- Это критично для научных расчётов, где cancellation ubiquitous.

## Возможные причины
- Ошибка в реализации ренормализации (например, head/tail не всегда корректно собирают остатки).
- Ошибка в TwoSum/TwoProd (например, не все ошибки попадают в поток компонент).
- Ошибка в логике SCRR_Tensor.from_float или арифметических операций (например, неверная инициализация компонент).
- Ошибка в тестах маловероятна, т.к. аналогичные паттерны ловятся и в property-based.

## Что делать
- Провести подробный аудит ренормализации и TwoSum/TwoProd.
- Проверить, что при cancellation head и tail действительно содержат все значимые разряды.
- Сравнить с эталонными реализациями (например, QDlib, float128).
- Добавить property-based тесты, которые специально генерируют cancellation-паттерны для разных k.

## Пример (repro)
```python
import torch
from scrr_fx._tensor import SCRR_Tensor
k = 8
x1 = SCRR_Tensor.from_float(torch.tensor(1.0), k=k)
x2 = SCRR_Tensor.from_float(torch.tensor(1.0 - 1e-16), k=k)
res = (x1 - x2).to_float().item()
print("SCRR k=8:", res)
print("float64:", 1.0 - (1.0 - 1e-16))
# Ожидается, что SCRR даст результат ближе к 1e-16, но иногда даёт 0.0
```

## Статус
- Проблема подтверждена property-based тестами и ручными примерами.
- Требует анализа и исправления.

---
**Если ты занимаешься ядром SCRR — начни с этого!** 